{"ast":null,"code":"(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module unless amdModuleId is set\n    define([], function () {\n      return root['Autolinker'] = factory();\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    root['Autolinker'] = factory();\n  }\n})(this, function () {\n  /*!\n   * Autolinker.js\n   * 0.15.3\n   *\n   * Copyright(c) 2015 Gregory Jacobs <greg@greg-jacobs.com>\n   * MIT Licensed. http://www.opensource.org/licenses/mit-license.php\n   *\n   * https://github.com/gregjacobs/Autolinker.js\n   */\n\n  /**\n   * @class Autolinker\n   * @extends Object\n   * \n   * Utility class used to process a given string of text, and wrap the URLs, email addresses, and Twitter handles in \n   * the appropriate anchor (&lt;a&gt;) tags to turn them into links.\n   * \n   * Any of the configuration options may be provided in an Object (map) provided to the Autolinker constructor, which\n   * will configure how the {@link #link link()} method will process the links.\n   * \n   * For example:\n   * \n   *     var autolinker = new Autolinker( {\n   *         newWindow : false,\n   *         truncate  : 30\n   *     } );\n   *     \n   *     var html = autolinker.link( \"Joe went to www.yahoo.com\" );\n   *     // produces: 'Joe went to <a href=\"http://www.yahoo.com\">yahoo.com</a>'\n   * \n   * \n   * The {@link #static-link static link()} method may also be used to inline options into a single call, which may\n   * be more convenient for one-off uses. For example:\n   * \n   *     var html = Autolinker.link( \"Joe went to www.yahoo.com\", {\n   *         newWindow : false,\n   *         truncate  : 30\n   *     } );\n   *     // produces: 'Joe went to <a href=\"http://www.yahoo.com\">yahoo.com</a>'\n   * \n   * \n   * ## Custom Replacements of Links\n   * \n   * If the configuration options do not provide enough flexibility, a {@link #replaceFn} may be provided to fully customize\n   * the output of Autolinker. This function is called once for each URL/Email/Twitter handle match that is encountered.\n   * \n   * For example:\n   * \n   *     var input = \"...\";  // string with URLs, Email Addresses, and Twitter Handles\n   *     \n   *     var linkedText = Autolinker.link( input, {\n   *         replaceFn : function( autolinker, match ) {\n   *             console.log( \"href = \", match.getAnchorHref() );\n   *             console.log( \"text = \", match.getAnchorText() );\n   *         \n   *             switch( match.getType() ) {\n   *                 case 'url' : \n   *                     console.log( \"url: \", match.getUrl() );\n   *                     \n   *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {\n   *                         var tag = autolinker.getTagBuilder().build( match );  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes\n   *                         tag.setAttr( 'rel', 'nofollow' );\n   *                         tag.addClass( 'external-link' );\n   *                         \n   *                         return tag;\n   *                         \n   *                     } else {\n   *                         return true;  // let Autolinker perform its normal anchor tag replacement\n   *                     }\n   *                     \n   *                 case 'email' :\n   *                     var email = match.getEmail();\n   *                     console.log( \"email: \", email );\n   *                     \n   *                     if( email === \"my@own.address\" ) {\n   *                         return false;  // don't auto-link this particular email address; leave as-is\n   *                     } else {\n   *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)\n   *                     }\n   *                 \n   *                 case 'twitter' :\n   *                     var twitterHandle = match.getTwitterHandle();\n   *                     console.log( twitterHandle );\n   *                     \n   *                     return '<a href=\"http://newplace.to.link.twitter.handles.to/\">' + twitterHandle + '</a>';\n   *             }\n   *         }\n   *     } );\n   * \n   * \n   * The function may return the following values:\n   * \n   * - `true` (Boolean): Allow Autolinker to replace the match as it normally would.\n   * - `false` (Boolean): Do not replace the current match at all - leave as-is.\n   * - Any String: If a string is returned from the function, the string will be used directly as the replacement HTML for\n   *   the match.\n   * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify an HTML tag before writing out its HTML text.\n   * \n   * @constructor\n   * @param {Object} [config] The configuration options for the Autolinker instance, specified in an Object (map).\n   */\n  var Autolinker = function Autolinker(cfg) {\n    Autolinker.Util.assign(this, cfg); // assign the properties of `cfg` onto the Autolinker instance. Prototype properties will be used for missing configs.\n  };\n\n  Autolinker.prototype = {\n    constructor: Autolinker,\n    // fix constructor property\n\n    /**\n     * @cfg {Boolean} urls\n     * \n     * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.\n     */\n    urls: true,\n\n    /**\n     * @cfg {Boolean} email\n     * \n     * `true` if email addresses should be automatically linked, `false` if they should not be.\n     */\n    email: true,\n\n    /**\n     * @cfg {Boolean} twitter\n     * \n     * `true` if Twitter handles (\"@example\") should be automatically linked, `false` if they should not be.\n     */\n    twitter: true,\n\n    /**\n     * @cfg {Boolean} newWindow\n     * \n     * `true` if the links should open in a new window, `false` otherwise.\n     */\n    newWindow: true,\n\n    /**\n     * @cfg {Boolean} stripPrefix\n     * \n     * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped from the beginning of URL links' text, \n     * `false` otherwise.\n     */\n    stripPrefix: true,\n\n    /**\n     * @cfg {Number} truncate\n     * \n     * A number for how many characters long URLs/emails/twitter handles should be truncated to inside the text of \n     * a link. If the URL/email/twitter is over this number of characters, it will be truncated to this length by \n     * adding a two period ellipsis ('..') to the end of the string.\n     * \n     * For example: A url like 'http://www.yahoo.com/some/long/path/to/a/file' truncated to 25 characters might look\n     * something like this: 'yahoo.com/some/long/pat..'\n     */\n    truncate: undefined,\n\n    /**\n     * @cfg {String} className\n     * \n     * A CSS class name to add to the generated links. This class will be added to all links, as well as this class\n     * plus url/email/twitter suffixes for styling url/email/twitter links differently.\n     * \n     * For example, if this config is provided as \"myLink\", then:\n     * \n     * - URL links will have the CSS classes: \"myLink myLink-url\"\n     * - Email links will have the CSS classes: \"myLink myLink-email\", and\n     * - Twitter links will have the CSS classes: \"myLink myLink-twitter\"\n     */\n    className: \"\",\n\n    /**\n     * @cfg {Function} replaceFn\n     * \n     * A function to individually process each URL/Email/Twitter match found in the input string.\n     * \n     * See the class's description for usage.\n     * \n     * This function is called with the following parameters:\n     * \n     * @cfg {Autolinker} replaceFn.autolinker The Autolinker instance, which may be used to retrieve child objects from (such\n     *   as the instance's {@link #getTagBuilder tag builder}).\n     * @cfg {Autolinker.match.Match} replaceFn.match The Match instance which can be used to retrieve information about the\n     *   {@link Autolinker.match.Url URL}/{@link Autolinker.match.Email email}/{@link Autolinker.match.Twitter Twitter}\n     *   match that the `replaceFn` is currently processing.\n     */\n\n    /**\n     * @private\n     * @property {Autolinker.htmlParser.HtmlParser} htmlParser\n     * \n     * The HtmlParser instance used to skip over HTML tags, while finding text nodes to process. This is lazily instantiated\n     * in the {@link #getHtmlParser} method.\n     */\n    htmlParser: undefined,\n\n    /**\n     * @private\n     * @property {Autolinker.matchParser.MatchParser} matchParser\n     * \n     * The MatchParser instance used to find URL/email/Twitter matches in the text nodes of an input string passed to\n     * {@link #link}. This is lazily instantiated in the {@link #getMatchParser} method.\n     */\n    matchParser: undefined,\n\n    /**\n     * @private\n     * @property {Autolinker.AnchorTagBuilder} tagBuilder\n     * \n     * The AnchorTagBuilder instance used to build the URL/email/Twitter replacement anchor tags. This is lazily instantiated\n     * in the {@link #getTagBuilder} method.\n     */\n    tagBuilder: undefined,\n\n    /**\n     * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML. \n     * Does not link URLs found within HTML tags.\n     * \n     * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result\n     * will be `You should go to &lt;a href=\"http://www.yahoo.com\"&gt;http://www.yahoo.com&lt;/a&gt;`\n     * \n     * This method finds the text around any HTML elements in the input `textOrHtml`, which will be the text that is processed.\n     * Any original HTML elements will be left as-is, as well as the text that is already wrapped in anchor (&lt;a&gt;) tags.\n     * \n     * @param {String} textOrHtml The HTML or text to link URLs, email addresses, and Twitter handles within (depending on if\n     *   the {@link #urls}, {@link #email}, and {@link #twitter} options are enabled).\n     * @return {String} The HTML, with URLs/emails/Twitter handles automatically linked.\n     */\n    link: function link(textOrHtml) {\n      var htmlParser = this.getHtmlParser(),\n          htmlNodes = htmlParser.parse(textOrHtml),\n          anchorTagStackCount = 0,\n          // used to only process text around anchor tags, and any inner text/html they may have\n      resultHtml = [];\n\n      for (var i = 0, len = htmlNodes.length; i < len; i++) {\n        var node = htmlNodes[i],\n            nodeType = node.getType(),\n            nodeText = node.getText();\n\n        if (nodeType === 'element') {\n          // Process HTML nodes in the input `textOrHtml`\n          if (node.getTagName() === 'a') {\n            if (!node.isClosing()) {\n              // it's the start <a> tag\n              anchorTagStackCount++;\n            } else {\n              // it's the end </a> tag\n              anchorTagStackCount = Math.max(anchorTagStackCount - 1, 0); // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0\n            }\n          }\n\n          resultHtml.push(nodeText); // now add the text of the tag itself verbatim\n        } else if (nodeType === 'entity') {\n          resultHtml.push(nodeText); // append HTML entity nodes (such as '&nbsp;') verbatim\n        } else {\n          // Process text nodes in the input `textOrHtml`\n          if (anchorTagStackCount === 0) {\n            // If we're not within an <a> tag, process the text node to linkify\n            var linkifiedStr = this.linkifyStr(nodeText);\n            resultHtml.push(linkifiedStr);\n          } else {\n            // `text` is within an <a> tag, simply append the text - we do not want to autolink anything \n            // already within an <a>...</a> tag\n            resultHtml.push(nodeText);\n          }\n        }\n      }\n\n      return resultHtml.join(\"\");\n    },\n\n    /**\n     * Process the text that lies in between HTML tags, performing the anchor tag replacements for matched \n     * URLs/emails/Twitter handles, and returns the string with the replacements made. \n     * \n     * This method does the actual wrapping of URLs/emails/Twitter handles with anchor tags.\n     * \n     * @private\n     * @param {String} str The string of text to auto-link.\n     * @return {String} The text with anchor tags auto-filled.\n     */\n    linkifyStr: function linkifyStr(str) {\n      return this.getMatchParser().replace(str, this.createMatchReturnVal, this);\n    },\n\n    /**\n     * Creates the return string value for a given match in the input string, for the {@link #processTextNode} method.\n     * \n     * This method handles the {@link #replaceFn}, if one was provided.\n     * \n     * @private\n     * @param {Autolinker.match.Match} match The Match object that represents the match.\n     * @return {String} The string that the `match` should be replaced with. This is usually the anchor tag string, but\n     *   may be the `matchStr` itself if the match is not to be replaced.\n     */\n    createMatchReturnVal: function createMatchReturnVal(match) {\n      // Handle a custom `replaceFn` being provided\n      var replaceFnResult;\n\n      if (this.replaceFn) {\n        replaceFnResult = this.replaceFn.call(this, this, match); // Autolinker instance is the context, and the first arg\n      }\n\n      if (typeof replaceFnResult === 'string') {\n        return replaceFnResult; // `replaceFn` returned a string, use that\n      } else if (replaceFnResult === false) {\n        return match.getMatchedText(); // no replacement for the match\n      } else if (replaceFnResult instanceof Autolinker.HtmlTag) {\n        return replaceFnResult.toString();\n      } else {\n        // replaceFnResult === true, or no/unknown return value from function\n        // Perform Autolinker's default anchor tag generation\n        var tagBuilder = this.getTagBuilder(),\n            anchorTag = tagBuilder.build(match); // returns an Autolinker.HtmlTag instance\n\n        return anchorTag.toString();\n      }\n    },\n\n    /**\n     * Lazily instantiates and returns the {@link #htmlParser} instance for this Autolinker instance.\n     * \n     * @protected\n     * @return {Autolinker.htmlParser.HtmlParser}\n     */\n    getHtmlParser: function getHtmlParser() {\n      var htmlParser = this.htmlParser;\n\n      if (!htmlParser) {\n        htmlParser = this.htmlParser = new Autolinker.htmlParser.HtmlParser();\n      }\n\n      return htmlParser;\n    },\n\n    /**\n     * Lazily instantiates and returns the {@link #matchParser} instance for this Autolinker instance.\n     * \n     * @protected\n     * @return {Autolinker.matchParser.MatchParser}\n     */\n    getMatchParser: function getMatchParser() {\n      var matchParser = this.matchParser;\n\n      if (!matchParser) {\n        matchParser = this.matchParser = new Autolinker.matchParser.MatchParser({\n          urls: this.urls,\n          email: this.email,\n          twitter: this.twitter,\n          stripPrefix: this.stripPrefix\n        });\n      }\n\n      return matchParser;\n    },\n\n    /**\n     * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it\n     * if it does not yet exist.\n     * \n     * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that \n     * Autolinker would normally generate, and then allow for modifications before returning it. For example:\n     * \n     *     var html = Autolinker.link( \"Test google.com\", {\n     *         replaceFn : function( autolinker, match ) {\n     *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance\n     *             tag.setAttr( 'rel', 'nofollow' );\n     *             \n     *             return tag;\n     *         }\n     *     } );\n     *     \n     *     // generated html:\n     *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n     * \n     * @return {Autolinker.AnchorTagBuilder}\n     */\n    getTagBuilder: function getTagBuilder() {\n      var tagBuilder = this.tagBuilder;\n\n      if (!tagBuilder) {\n        tagBuilder = this.tagBuilder = new Autolinker.AnchorTagBuilder({\n          newWindow: this.newWindow,\n          truncate: this.truncate,\n          className: this.className\n        });\n      }\n\n      return tagBuilder;\n    }\n  };\n  /**\n   * Automatically links URLs, email addresses, and Twitter handles found in the given chunk of HTML. \n   * Does not link URLs found within HTML tags.\n   * \n   * For instance, if given the text: `You should go to http://www.yahoo.com`, then the result\n   * will be `You should go to &lt;a href=\"http://www.yahoo.com\"&gt;http://www.yahoo.com&lt;/a&gt;`\n   * \n   * Example:\n   * \n   *     var linkedText = Autolinker.link( \"Go to google.com\", { newWindow: false } );\n   *     // Produces: \"Go to <a href=\"http://google.com\">google.com</a>\"\n   * \n   * @static\n   * @param {String} textOrHtml The HTML or text to find URLs, email addresses, and Twitter handles within (depending on if\n   *   the {@link #urls}, {@link #email}, and {@link #twitter} options are enabled).\n   * @param {Object} [options] Any of the configuration options for the Autolinker class, specified in an Object (map).\n   *   See the class description for an example call.\n   * @return {String} The HTML text, with URLs automatically linked\n   */\n\n  Autolinker.link = function (textOrHtml, options) {\n    var autolinker = new Autolinker(options);\n    return autolinker.link(textOrHtml);\n  }; // Autolinker Namespaces\n\n\n  Autolinker.match = {};\n  Autolinker.htmlParser = {};\n  Autolinker.matchParser = {};\n  /*global Autolinker */\n\n  /*jshint eqnull:true, boss:true */\n\n  /**\n   * @class Autolinker.Util\n   * @singleton\n   * \n   * A few utility methods for Autolinker.\n   */\n\n  Autolinker.Util = {\n    /**\n     * @property {Function} abstractMethod\n     * \n     * A function object which represents an abstract method.\n     */\n    abstractMethod: function abstractMethod() {\n      throw \"abstract\";\n    },\n\n    /**\n     * Assigns (shallow copies) the properties of `src` onto `dest`.\n     * \n     * @param {Object} dest The destination object.\n     * @param {Object} src The source object.\n     * @return {Object} The destination object (`dest`)\n     */\n    assign: function assign(dest, src) {\n      for (var prop in src) {\n        if (src.hasOwnProperty(prop)) {\n          dest[prop] = src[prop];\n        }\n      }\n\n      return dest;\n    },\n\n    /**\n     * Extends `superclass` to create a new subclass, adding the `protoProps` to the new subclass's prototype.\n     * \n     * @param {Function} superclass The constructor function for the superclass.\n     * @param {Object} protoProps The methods/properties to add to the subclass's prototype. This may contain the\n     *   special property `constructor`, which will be used as the new subclass's constructor function.\n     * @return {Function} The new subclass function.\n     */\n    extend: function extend(superclass, protoProps) {\n      var superclassProto = superclass.prototype;\n\n      var F = function F() {};\n\n      F.prototype = superclassProto;\n      var subclass;\n\n      if (protoProps.hasOwnProperty('constructor')) {\n        subclass = protoProps.constructor;\n      } else {\n        subclass = function subclass() {\n          superclassProto.constructor.apply(this, arguments);\n        };\n      }\n\n      var subclassProto = subclass.prototype = new F(); // set up prototype chain\n\n      subclassProto.constructor = subclass; // fix constructor property\n\n      subclassProto.superclass = superclassProto;\n      delete protoProps.constructor; // don't re-assign constructor property to the prototype, since a new function may have been created (`subclass`), which is now already there\n\n      Autolinker.Util.assign(subclassProto, protoProps);\n      return subclass;\n    },\n\n    /**\n     * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the\n     * end of the string (by default, two periods: '..'). If the `str` length does not exceed \n     * `len`, the string will be returned unchanged.\n     * \n     * @param {String} str The string to truncate and add an ellipsis to.\n     * @param {Number} truncateLen The length to truncate the string at.\n     * @param {String} [ellipsisChars=..] The ellipsis character(s) to add to the end of `str`\n     *   when truncated. Defaults to '..'\n     */\n    ellipsis: function ellipsis(str, truncateLen, ellipsisChars) {\n      if (str.length > truncateLen) {\n        ellipsisChars = ellipsisChars == null ? '..' : ellipsisChars;\n        str = str.substring(0, truncateLen - ellipsisChars.length) + ellipsisChars;\n      }\n\n      return str;\n    },\n\n    /**\n     * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).\n     * \n     * @param {Array} arr The array to find an element of.\n     * @param {*} element The element to find in the array, and return the index of.\n     * @return {Number} The index of the `element`, or -1 if it was not found.\n     */\n    indexOf: function indexOf(arr, element) {\n      if (Array.prototype.indexOf) {\n        return arr.indexOf(element);\n      } else {\n        for (var i = 0, len = arr.length; i < len; i++) {\n          if (arr[i] === element) return i;\n        }\n\n        return -1;\n      }\n    },\n\n    /**\n     * Performs the functionality of what modern browsers do when `String.prototype.split()` is called\n     * with a regular expression that contains capturing parenthesis.\n     * \n     * For example:\n     * \n     *     // Modern browsers: \n     *     \"a,b,c\".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]\n     *     \n     *     // Old IE (including IE8):\n     *     \"a,b,c\".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]\n     *     \n     * This method emulates the functionality of modern browsers for the old IE case.\n     * \n     * @param {String} str The string to split.\n     * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting\n     *   character(s) will be spliced into the array, as in the \"modern browsers\" example in the \n     *   description of this method. \n     *   Note #1: the supplied regular expression **must** have the 'g' flag specified.\n     *   Note #2: for simplicity's sake, the regular expression does not need \n     *   to contain capturing parenthesis - it will be assumed that any match has them.\n     * @return {String[]} The split array of strings, with the splitting character(s) included.\n     */\n    splitAndCapture: function splitAndCapture(str, splitRegex) {\n      if (!splitRegex.global) throw new Error(\"`splitRegex` must have the 'g' flag set\");\n      var result = [],\n          lastIdx = 0,\n          match;\n\n      while (match = splitRegex.exec(str)) {\n        result.push(str.substring(lastIdx, match.index));\n        result.push(match[0]); // push the splitting char(s)\n\n        lastIdx = match.index + match[0].length;\n      }\n\n      result.push(str.substring(lastIdx));\n      return result;\n    }\n  };\n  /*global Autolinker */\n\n  /*jshint boss:true */\n\n  /**\n   * @class Autolinker.HtmlTag\n   * @extends Object\n   * \n   * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.\n   * \n   * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use\n   * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.\n   * \n   * ## Examples\n   * \n   * Example instantiation:\n   * \n   *     var tag = new Autolinker.HtmlTag( {\n   *         tagName : 'a',\n   *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },\n   *         innerHtml : 'Google'\n   *     } );\n   *     \n   *     tag.toString();  // <a href=\"http://google.com\" class=\"external-link\">Google</a>\n   *     \n   *     // Individual accessor methods\n   *     tag.getTagName();                 // 'a'\n   *     tag.getAttr( 'href' );            // 'http://google.com'\n   *     tag.hasClass( 'external-link' );  // true\n   * \n   * \n   * Using mutator methods (which may be used in combination with instantiation config properties):\n   * \n   *     var tag = new Autolinker.HtmlTag();\n   *     tag.setTagName( 'a' );\n   *     tag.setAttr( 'href', 'http://google.com' );\n   *     tag.addClass( 'external-link' );\n   *     tag.setInnerHtml( 'Google' );\n   *     \n   *     tag.getTagName();                 // 'a'\n   *     tag.getAttr( 'href' );            // 'http://google.com'\n   *     tag.hasClass( 'external-link' );  // true\n   *     \n   *     tag.toString();  // <a href=\"http://google.com\" class=\"external-link\">Google</a>\n   *     \n   * \n   * ## Example use within a {@link Autolinker#replaceFn replaceFn}\n   * \n   *     var html = Autolinker.link( \"Test google.com\", {\n   *         replaceFn : function( autolinker, match ) {\n   *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text\n   *             tag.setAttr( 'rel', 'nofollow' );\n   *             \n   *             return tag;\n   *         }\n   *     } );\n   *     \n   *     // generated html:\n   *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n   *     \n   *     \n   * ## Example use with a new tag for the replacement\n   * \n   *     var html = Autolinker.link( \"Test google.com\", {\n   *         replaceFn : function( autolinker, match ) {\n   *             var tag = new Autolinker.HtmlTag( {\n   *                 tagName : 'button',\n   *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },\n   *                 innerHtml : 'Load URL: ' + match.getAnchorText()\n   *             } );\n   *             \n   *             return tag;\n   *         }\n   *     } );\n   *     \n   *     // generated html:\n   *     //   Test <button title=\"Load URL: http://google.com\">Load URL: google.com</button>\n   */\n\n  Autolinker.HtmlTag = Autolinker.Util.extend(Object, {\n    /**\n     * @cfg {String} tagName\n     * \n     * The tag name. Ex: 'a', 'button', etc.\n     * \n     * Not required at instantiation time, but should be set using {@link #setTagName} before {@link #toString}\n     * is executed.\n     */\n\n    /**\n     * @cfg {Object.<String, String>} attrs\n     * \n     * An key/value Object (map) of attributes to create the tag with. The keys are the attribute names, and the\n     * values are the attribute values.\n     */\n\n    /**\n     * @cfg {String} innerHtml\n     * \n     * The inner HTML for the tag. \n     * \n     * Note the camel case name on `innerHtml`. Acronyms are camelCased in this utility (such as not to run into the acronym \n     * naming inconsistency that the DOM developers created with `XMLHttpRequest`). You may alternatively use {@link #innerHTML}\n     * if you prefer, but this one is recommended.\n     */\n\n    /**\n     * @cfg {String} innerHTML\n     * \n     * Alias of {@link #innerHtml}, accepted for consistency with the browser DOM api, but prefer the camelCased version\n     * for acronym names.\n     */\n\n    /**\n     * @protected\n     * @property {RegExp} whitespaceRegex\n     * \n     * Regular expression used to match whitespace in a string of CSS classes.\n     */\n    whitespaceRegex: /\\s+/,\n\n    /**\n     * @constructor\n     * @param {Object} [cfg] The configuration properties for this class, in an Object (map)\n     */\n    constructor: function constructor(cfg) {\n      Autolinker.Util.assign(this, cfg);\n      this.innerHtml = this.innerHtml || this.innerHTML; // accept either the camelCased form or the fully capitalized acronym\n    },\n\n    /**\n     * Sets the tag name that will be used to generate the tag with.\n     * \n     * @param {String} tagName\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    setTagName: function setTagName(tagName) {\n      this.tagName = tagName;\n      return this;\n    },\n\n    /**\n     * Retrieves the tag name.\n     * \n     * @return {String}\n     */\n    getTagName: function getTagName() {\n      return this.tagName || \"\";\n    },\n\n    /**\n     * Sets an attribute on the HtmlTag.\n     * \n     * @param {String} attrName The attribute name to set.\n     * @param {String} attrValue The attribute value to set.\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    setAttr: function setAttr(attrName, attrValue) {\n      var tagAttrs = this.getAttrs();\n      tagAttrs[attrName] = attrValue;\n      return this;\n    },\n\n    /**\n     * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.\n     * \n     * @param {String} name The attribute name to retrieve.\n     * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.\n     */\n    getAttr: function getAttr(attrName) {\n      return this.getAttrs()[attrName];\n    },\n\n    /**\n     * Sets one or more attributes on the HtmlTag.\n     * \n     * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    setAttrs: function setAttrs(attrs) {\n      var tagAttrs = this.getAttrs();\n      Autolinker.Util.assign(tagAttrs, attrs);\n      return this;\n    },\n\n    /**\n     * Retrieves the attributes Object (map) for the HtmlTag.\n     * \n     * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.\n     */\n    getAttrs: function getAttrs() {\n      return this.attrs || (this.attrs = {});\n    },\n\n    /**\n     * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.\n     * \n     * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    setClass: function setClass(cssClass) {\n      return this.setAttr('class', cssClass);\n    },\n\n    /**\n     * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.\n     * \n     * @param {String} cssClass One or more space-separated CSS classes to add.\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    addClass: function addClass(cssClass) {\n      var classAttr = this.getClass(),\n          whitespaceRegex = this.whitespaceRegex,\n          indexOf = Autolinker.Util.indexOf,\n          // to support IE8 and below\n      classes = !classAttr ? [] : classAttr.split(whitespaceRegex),\n          newClasses = cssClass.split(whitespaceRegex),\n          newClass;\n\n      while (newClass = newClasses.shift()) {\n        if (indexOf(classes, newClass) === -1) {\n          classes.push(newClass);\n        }\n      }\n\n      this.getAttrs()['class'] = classes.join(\" \");\n      return this;\n    },\n\n    /**\n     * Convenience method to remove one or more CSS classes from the HtmlTag.\n     * \n     * @param {String} cssClass One or more space-separated CSS classes to remove.\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    removeClass: function removeClass(cssClass) {\n      var classAttr = this.getClass(),\n          whitespaceRegex = this.whitespaceRegex,\n          indexOf = Autolinker.Util.indexOf,\n          // to support IE8 and below\n      classes = !classAttr ? [] : classAttr.split(whitespaceRegex),\n          removeClasses = cssClass.split(whitespaceRegex),\n          removeClass;\n\n      while (classes.length && (removeClass = removeClasses.shift())) {\n        var idx = indexOf(classes, removeClass);\n\n        if (idx !== -1) {\n          classes.splice(idx, 1);\n        }\n      }\n\n      this.getAttrs()['class'] = classes.join(\" \");\n      return this;\n    },\n\n    /**\n     * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when\n     * there are multiple.\n     * \n     * @return {String}\n     */\n    getClass: function getClass() {\n      return this.getAttrs()['class'] || \"\";\n    },\n\n    /**\n     * Convenience method to check if the tag has a CSS class or not.\n     * \n     * @param {String} cssClass The CSS class to check for.\n     * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.\n     */\n    hasClass: function hasClass(cssClass) {\n      return (' ' + this.getClass() + ' ').indexOf(' ' + cssClass + ' ') !== -1;\n    },\n\n    /**\n     * Sets the inner HTML for the tag.\n     * \n     * @param {String} html The inner HTML to set.\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    setInnerHtml: function setInnerHtml(html) {\n      this.innerHtml = html;\n      return this;\n    },\n\n    /**\n     * Retrieves the inner HTML for the tag.\n     * \n     * @return {String}\n     */\n    getInnerHtml: function getInnerHtml() {\n      return this.innerHtml || \"\";\n    },\n\n    /**\n     * Override of superclass method used to generate the HTML string for the tag.\n     * \n     * @return {String}\n     */\n    toString: function toString() {\n      var tagName = this.getTagName(),\n          attrsStr = this.buildAttrsStr();\n      attrsStr = attrsStr ? ' ' + attrsStr : ''; // prepend a space if there are actually attributes\n\n      return ['<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>'].join(\"\");\n    },\n\n    /**\n     * Support method for {@link #toString}, returns the string space-separated key=\"value\" pairs, used to populate \n     * the stringified HtmlTag.\n     * \n     * @protected\n     * @return {String} Example return: `attr1=\"value1\" attr2=\"value2\"`\n     */\n    buildAttrsStr: function buildAttrsStr() {\n      if (!this.attrs) return \"\"; // no `attrs` Object (map) has been set, return empty string\n\n      var attrs = this.getAttrs(),\n          attrsArr = [];\n\n      for (var prop in attrs) {\n        if (attrs.hasOwnProperty(prop)) {\n          attrsArr.push(prop + '=\"' + attrs[prop] + '\"');\n        }\n      }\n\n      return attrsArr.join(\" \");\n    }\n  });\n  /*global Autolinker */\n\n  /*jshint sub:true */\n\n  /**\n   * @protected\n   * @class Autolinker.AnchorTagBuilder\n   * @extends Object\n   * \n   * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is found.\n   * \n   * Normally this class is instantiated, configured, and used internally by an {@link Autolinker} instance, but may \n   * actually be retrieved in a {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag} instances\n   * which may be modified before returning from the {@link Autolinker#replaceFn replaceFn}. For example:\n   * \n   *     var html = Autolinker.link( \"Test google.com\", {\n   *         replaceFn : function( autolinker, match ) {\n   *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance\n   *             tag.setAttr( 'rel', 'nofollow' );\n   *             \n   *             return tag;\n   *         }\n   *     } );\n   *     \n   *     // generated html:\n   *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n   */\n\n  Autolinker.AnchorTagBuilder = Autolinker.Util.extend(Object, {\n    /**\n     * @cfg {Boolean} newWindow\n     * @inheritdoc Autolinker#newWindow\n     */\n\n    /**\n     * @cfg {Number} truncate\n     * @inheritdoc Autolinker#truncate\n     */\n\n    /**\n     * @cfg {String} className\n     * @inheritdoc Autolinker#className\n     */\n\n    /**\n     * @constructor\n     * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).\n     */\n    constructor: function constructor(cfg) {\n      Autolinker.Util.assign(this, cfg);\n    },\n\n    /**\n     * Generates the actual anchor (&lt;a&gt;) tag to use in place of the matched URL/email/Twitter text,\n     * via its `match` object.\n     * \n     * @param {Autolinker.match.Match} match The Match instance to generate an anchor tag from.\n     * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.\n     */\n    build: function build(match) {\n      var tag = new Autolinker.HtmlTag({\n        tagName: 'a',\n        attrs: this.createAttrs(match.getType(), match.getAnchorHref()),\n        innerHtml: this.processAnchorText(match.getAnchorText())\n      });\n      return tag;\n    },\n\n    /**\n     * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;) tag being generated.\n     * \n     * @protected\n     * @param {\"url\"/\"email\"/\"twitter\"} matchType The type of match that an anchor tag is being generated for.\n     * @param {String} href The href for the anchor tag.\n     * @return {Object} A key/value Object (map) of the anchor tag's attributes. \n     */\n    createAttrs: function createAttrs(matchType, anchorHref) {\n      var attrs = {\n        'href': anchorHref // we'll always have the `href` attribute\n\n      };\n      var cssClass = this.createCssClass(matchType);\n\n      if (cssClass) {\n        attrs['class'] = cssClass;\n      }\n\n      if (this.newWindow) {\n        attrs['target'] = \"_blank\";\n      }\n\n      return attrs;\n    },\n\n    /**\n     * Creates the CSS class that will be used for a given anchor tag, based on the `matchType` and the {@link #className}\n     * config.\n     * \n     * @private\n     * @param {\"url\"/\"email\"/\"twitter\"} matchType The type of match that an anchor tag is being generated for.\n     * @return {String} The CSS class string for the link. Example return: \"myLink myLink-url\". If no {@link #className}\n     *   was configured, returns an empty string.\n     */\n    createCssClass: function createCssClass(matchType) {\n      var className = this.className;\n      if (!className) return \"\";else return className + \" \" + className + \"-\" + matchType; // ex: \"myLink myLink-url\", \"myLink myLink-email\", or \"myLink myLink-twitter\"\n    },\n\n    /**\n     * Processes the `anchorText` by truncating the text according to the {@link #truncate} config.\n     * \n     * @private\n     * @param {String} anchorText The anchor tag's text (i.e. what will be displayed).\n     * @return {String} The processed `anchorText`.\n     */\n    processAnchorText: function processAnchorText(anchorText) {\n      anchorText = this.doTruncate(anchorText);\n      return anchorText;\n    },\n\n    /**\n     * Performs the truncation of the `anchorText`, if the `anchorText` is longer than the {@link #truncate} option.\n     * Truncates the text to 2 characters fewer than the {@link #truncate} option, and adds \"..\" to the end.\n     * \n     * @private\n     * @param {String} text The anchor tag's text (i.e. what will be displayed).\n     * @return {String} The truncated anchor text.\n     */\n    doTruncate: function doTruncate(anchorText) {\n      return Autolinker.Util.ellipsis(anchorText, this.truncate || Number.POSITIVE_INFINITY);\n    }\n  });\n  /*global Autolinker */\n\n  /**\n   * @private\n   * @class Autolinker.htmlParser.HtmlParser\n   * @extends Object\n   * \n   * An HTML parser implementation which simply walks an HTML string and returns an array of \n   * {@link Autolinker.htmlParser.HtmlNode HtmlNodes} that represent the basic HTML structure of the input string.\n   * \n   * Autolinker uses this to only link URLs/emails/Twitter handles within text nodes, effectively ignoring / \"walking\n   * around\" HTML tags.\n   */\n\n  Autolinker.htmlParser.HtmlParser = Autolinker.Util.extend(Object, {\n    /**\n     * @private\n     * @property {RegExp} htmlRegex\n     * \n     * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and\n     * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.\n     * \n     * Capturing groups:\n     * \n     * 1. The \"!DOCTYPE\" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.\n     * 2. If it is an end tag, this group will have the '/'.\n     * 3. The tag name for all tags (other than the &lt;!DOCTYPE&gt; tag)\n     */\n    htmlRegex: function () {\n      var tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,\n          attrNameRegex = /[^\\s\\0\"'>\\/=\\x01-\\x1F\\x7F]+/,\n          // the unicode range accounts for excluding control chars, and the delete char\n      attrValueRegex = /(?:\"[^\"]*?\"|'[^']*?'|[^'\"=<>`\\s]+)/,\n          // double quoted, single quoted, or unquoted attribute values\n      nameEqualsValueRegex = attrNameRegex.source + '(?:\\\\s*=\\\\s*' + attrValueRegex.source + ')?'; // optional '=[value]'\n\n      return new RegExp([// for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">) \n      '(?:', '<(!DOCTYPE)', // *** Capturing Group 1 - If it's a doctype tag\n      // Zero or more attributes following the tag name\n      '(?:', '\\\\s+', // one or more whitespace chars before an attribute\n      // Either:\n      // A. attr=\"value\", or \n      // B. \"value\" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">) \n      '(?:', nameEqualsValueRegex, '|', attrValueRegex.source + ')', ')*', '>', ')', '|', // All other HTML tags (i.e. tags that are not <!DOCTYPE>)\n      '(?:', '<(/)?', // Beginning of a tag. Either '<' for a start tag, or '</' for an end tag. \n      // *** Capturing Group 2: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.\n      // *** Capturing Group 3 - The tag name\n      '(' + tagNameRegex.source + ')', // Zero or more attributes following the tag name\n      '(?:', '\\\\s+', // one or more whitespace chars before an attribute\n      nameEqualsValueRegex, // attr=\"value\" (with optional =\"value\" part)\n      ')*', '\\\\s*/?', // any trailing spaces and optional '/' before the closing '>'\n      '>', ')'].join(\"\"), 'gi');\n    }(),\n\n    /**\n     * @private\n     * @property {RegExp} htmlCharacterEntitiesRegex\n     *\n     * The regular expression that matches common HTML character entities.\n     * \n     * Ignoring &amp; as it could be part of a query string -- handling it separately.\n     */\n    htmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,\n\n    /**\n     * Parses an HTML string and returns a simple array of {@link Autolinker.htmlParser.HtmlNode HtmlNodes} to represent\n     * the HTML structure of the input string. \n     * \n     * @param {String} html The HTML to parse.\n     * @return {Autolinker.htmlParser.HtmlNode[]}\n     */\n    parse: function parse(html) {\n      var htmlRegex = this.htmlRegex,\n          currentResult,\n          lastIndex = 0,\n          textAndEntityNodes,\n          nodes = []; // will be the result of the method\n\n      while ((currentResult = htmlRegex.exec(html)) !== null) {\n        var tagText = currentResult[0],\n            tagName = currentResult[1] || currentResult[3],\n            // The <!DOCTYPE> tag (ex: \"!DOCTYPE\"), or another tag (ex: \"a\" or \"img\") \n        isClosingTag = !!currentResult[2],\n            inBetweenTagsText = html.substring(lastIndex, currentResult.index); // Push TextNodes and EntityNodes for any text found between tags\n\n        if (inBetweenTagsText) {\n          textAndEntityNodes = this.parseTextAndEntityNodes(inBetweenTagsText);\n          nodes.push.apply(nodes, textAndEntityNodes);\n        } // Push the ElementNode\n\n\n        nodes.push(this.createElementNode(tagText, tagName, isClosingTag));\n        lastIndex = currentResult.index + tagText.length;\n      } // Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.\n\n\n      if (lastIndex < html.length) {\n        var text = html.substring(lastIndex); // Push TextNodes and EntityNodes for any text found between tags\n\n        if (text) {\n          textAndEntityNodes = this.parseTextAndEntityNodes(text);\n          nodes.push.apply(nodes, textAndEntityNodes);\n        }\n      }\n\n      return nodes;\n    },\n\n    /**\n     * Parses text and HTML entity nodes from a given string. The input string should not have any HTML tags (elements)\n     * within it.\n     * \n     * @private\n     * @param {String} text The text to parse.\n     * @return {Autolinker.htmlParser.HtmlNode[]} An array of HtmlNodes to represent the \n     *   {@link Autolinker.htmlParser.TextNode TextNodes} and {@link Autolinker.htmlParser.EntityNode EntityNodes} found.\n     */\n    parseTextAndEntityNodes: function parseTextAndEntityNodes(text) {\n      var nodes = [],\n          textAndEntityTokens = Autolinker.Util.splitAndCapture(text, this.htmlCharacterEntitiesRegex); // split at HTML entities, but include the HTML entities in the results array\n      // Every even numbered token is a TextNode, and every odd numbered token is an EntityNode\n      // For example: an input `text` of \"Test &quot;this&quot; today\" would turn into the \n      //   `textAndEntityTokens`: [ 'Test ', '&quot;', 'this', '&quot;', ' today' ]\n\n      for (var i = 0, len = textAndEntityTokens.length; i < len; i += 2) {\n        var textToken = textAndEntityTokens[i],\n            entityToken = textAndEntityTokens[i + 1];\n        if (textToken) nodes.push(this.createTextNode(textToken));\n        if (entityToken) nodes.push(this.createEntityNode(entityToken));\n      }\n\n      return nodes;\n    },\n\n    /**\n     * Factory method to create an {@link Autolinker.htmlParser.ElementNode ElementNode}.\n     * \n     * @private\n     * @param {String} tagText The full text of the tag (element) that was matched, including its attributes.\n     * @param {String} tagName The name of the tag. Ex: An &lt;img&gt; tag would be passed to this method as \"img\".\n     * @param {Boolean} isClosingTag `true` if it's a closing tag, false otherwise.\n     * @return {Autolinker.htmlParser.ElementNode}\n     */\n    createElementNode: function createElementNode(tagText, tagName, isClosingTag) {\n      return new Autolinker.htmlParser.ElementNode({\n        text: tagText,\n        tagName: tagName.toLowerCase(),\n        closing: isClosingTag\n      });\n    },\n\n    /**\n     * Factory method to create a {@link Autolinker.htmlParser.EntityNode EntityNode}.\n     * \n     * @private\n     * @param {String} text The text that was matched for the HTML entity (such as '&amp;nbsp;').\n     * @return {Autolinker.htmlParser.EntityNode}\n     */\n    createEntityNode: function createEntityNode(text) {\n      return new Autolinker.htmlParser.EntityNode({\n        text: text\n      });\n    },\n\n    /**\n     * Factory method to create a {@link Autolinker.htmlParser.TextNode TextNode}.\n     * \n     * @private\n     * @param {String} text The text that was matched.\n     * @return {Autolinker.htmlParser.TextNode}\n     */\n    createTextNode: function createTextNode(text) {\n      return new Autolinker.htmlParser.TextNode({\n        text: text\n      });\n    }\n  });\n  /*global Autolinker */\n\n  /**\n   * @abstract\n   * @class Autolinker.htmlParser.HtmlNode\n   * \n   * Represents an HTML node found in an input string. An HTML node is one of the following:\n   * \n   * 1. An {@link Autolinker.htmlParser.ElementNode ElementNode}, which represents HTML tags.\n   * 2. A {@link Autolinker.htmlParser.TextNode TextNode}, which represents text outside or within HTML tags.\n   * 3. A {@link Autolinker.htmlParser.EntityNode EntityNode}, which represents one of the known HTML\n   *    entities that Autolinker looks for. This includes common ones such as &amp;quot; and &amp;nbsp;\n   */\n\n  Autolinker.htmlParser.HtmlNode = Autolinker.Util.extend(Object, {\n    /**\n     * @cfg {String} text (required)\n     * \n     * The original text that was matched for the HtmlNode. \n     * \n     * - In the case of an {@link Autolinker.htmlParser.ElementNode ElementNode}, this will be the tag's\n     *   text.\n     * - In the case of a {@link Autolinker.htmlParser.TextNode TextNode}, this will be the text itself.\n     * - In the case of a {@link Autolinker.htmlParser.EntityNode EntityNode}, this will be the text of\n     *   the HTML entity.\n     */\n    text: \"\",\n\n    /**\n     * @constructor\n     * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).\n     */\n    constructor: function constructor(cfg) {\n      Autolinker.Util.assign(this, cfg);\n    },\n\n    /**\n     * Returns a string name for the type of node that this class represents.\n     * \n     * @abstract\n     * @return {String}\n     */\n    getType: Autolinker.Util.abstractMethod,\n\n    /**\n     * Retrieves the {@link #text} for the HtmlNode.\n     * \n     * @return {String}\n     */\n    getText: function getText() {\n      return this.text;\n    }\n  });\n  /*global Autolinker */\n\n  /**\n   * @class Autolinker.htmlParser.ElementNode\n   * @extends Autolinker.htmlParser.HtmlNode\n   * \n   * Represents an HTML element node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n   * \n   * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.\n   */\n\n  Autolinker.htmlParser.ElementNode = Autolinker.Util.extend(Autolinker.htmlParser.HtmlNode, {\n    /**\n     * @cfg {String} tagName (required)\n     * \n     * The name of the tag that was matched.\n     */\n    tagName: '',\n\n    /**\n     * @cfg {Boolean} closing (required)\n     * \n     * `true` if the element (tag) is a closing tag, `false` if its an opening tag.\n     */\n    closing: false,\n\n    /**\n     * Returns a string name for the type of node that this class represents.\n     * \n     * @return {String}\n     */\n    getType: function getType() {\n      return 'element';\n    },\n\n    /**\n     * Returns the HTML element's (tag's) name. Ex: for an &lt;img&gt; tag, returns \"img\".\n     * \n     * @return {String}\n     */\n    getTagName: function getTagName() {\n      return this.tagName;\n    },\n\n    /**\n     * Determines if the HTML element (tag) is a closing tag. Ex: &lt;div&gt; returns\n     * `false`, while &lt;/div&gt; returns `true`.\n     * \n     * @return {Boolean}\n     */\n    isClosing: function isClosing() {\n      return this.closing;\n    }\n  });\n  /*global Autolinker */\n\n  /**\n   * @class Autolinker.htmlParser.EntityNode\n   * @extends Autolinker.htmlParser.HtmlNode\n   * \n   * Represents a known HTML entity node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n   * Ex: '&amp;nbsp;', or '&amp#160;' (which will be retrievable from the {@link #getText} method.\n   * \n   * Note that this class will only be returned from the HtmlParser for the set of checked HTML entity nodes \n   * defined by the {@link Autolinker.htmlParser.HtmlParser#htmlCharacterEntitiesRegex}.\n   * \n   * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.\n   */\n\n  Autolinker.htmlParser.EntityNode = Autolinker.Util.extend(Autolinker.htmlParser.HtmlNode, {\n    /**\n     * Returns a string name for the type of node that this class represents.\n     * \n     * @return {String}\n     */\n    getType: function getType() {\n      return 'entity';\n    }\n  });\n  /*global Autolinker */\n\n  /**\n   * @class Autolinker.htmlParser.TextNode\n   * @extends Autolinker.htmlParser.HtmlNode\n   * \n   * Represents a text node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n   * \n   * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.\n   */\n\n  Autolinker.htmlParser.TextNode = Autolinker.Util.extend(Autolinker.htmlParser.HtmlNode, {\n    /**\n     * Returns a string name for the type of node that this class represents.\n     * \n     * @return {String}\n     */\n    getType: function getType() {\n      return 'text';\n    }\n  });\n  /*global Autolinker */\n\n  /**\n   * @private\n   * @class Autolinker.matchParser.MatchParser\n   * @extends Object\n   * \n   * Used by Autolinker to parse {@link #urls URLs}, {@link #emails email addresses}, and {@link #twitter Twitter handles}, \n   * given an input string of text.\n   * \n   * The MatchParser is fed a non-HTML string in order to search out URLs, email addresses and Twitter handles. Autolinker\n   * first uses the {@link HtmlParser} to \"walk around\" HTML tags, and then the text around the HTML tags is passed into\n   * the MatchParser in order to find the actual matches.\n   */\n\n  Autolinker.matchParser.MatchParser = Autolinker.Util.extend(Object, {\n    /**\n     * @cfg {Boolean} urls\n     * \n     * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.\n     */\n    urls: true,\n\n    /**\n     * @cfg {Boolean} email\n     * \n     * `true` if email addresses should be automatically linked, `false` if they should not be.\n     */\n    email: true,\n\n    /**\n     * @cfg {Boolean} twitter\n     * \n     * `true` if Twitter handles (\"@example\") should be automatically linked, `false` if they should not be.\n     */\n    twitter: true,\n\n    /**\n     * @cfg {Boolean} stripPrefix\n     * \n     * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped from the beginning of URL links' text\n     * in {@link Autolinker.match.Url URL matches}, `false` otherwise.\n     * \n     * TODO: Handle this before a URL Match object is instantiated.\n     */\n    stripPrefix: true,\n\n    /**\n     * @private\n     * @property {RegExp} matcherRegex\n     * \n     * The regular expression that matches URLs, email addresses, and Twitter handles.\n     * \n     * This regular expression has the following capturing groups:\n     * \n     * 1. Group that is used to determine if there is a Twitter handle match (i.e. \\@someTwitterUser). Simply check for its \n     *    existence to determine if there is a Twitter handle match. The next couple of capturing groups give information \n     *    about the Twitter handle match.\n     * 2. The whitespace character before the \\@sign in a Twitter handle. This is needed because there are no lookbehinds in\n     *    JS regular expressions, and can be used to reconstruct the original string in a replace().\n     * 3. The Twitter handle itself in a Twitter match. If the match is '@someTwitterUser', the handle is 'someTwitterUser'.\n     * 4. Group that matches an email address. Used to determine if the match is an email address, as well as holding the full \n     *    address. Ex: 'me@my.com'\n     * 5. Group that matches a URL in the input text. Ex: 'http://google.com', 'www.google.com', or just 'google.com'.\n     *    This also includes a path, url parameters, or hash anchors. Ex: google.com/path/to/file?q1=1&q2=2#myAnchor\n     * 6. Group that matches a protocol URL (i.e. 'http://google.com'). This is used to match protocol URLs with just a single\n     *    word, like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.\n     * 7. A protocol-relative ('//') match for the case of a 'www.' prefixed URL. Will be an empty string if it is not a \n     *    protocol-relative match. We need to know the character before the '//' in order to determine if it is a valid match\n     *    or the // was in a string we don't want to auto-link.\n     * 8. A protocol-relative ('//') match for the case of a known TLD prefixed URL. Will be an empty string if it is not a \n     *    protocol-relative match. See #6 for more info. \n     */\n    matcherRegex: function () {\n      var twitterRegex = /(^|[^\\w])@(\\w{1,15})/,\n          // For matching a twitter handle. Ex: @gregory_jacobs\n      emailRegex = /(?:[\\-;:&=\\+\\$,\\w\\.]+@)/,\n          // something@ for email addresses (a.k.a. local-part)\n      protocolRegex = /(?:[A-Za-z][-.+A-Za-z0-9]+:(?![A-Za-z][-.+A-Za-z0-9]+:\\/\\/)(?!\\d+\\/?)(?:\\/\\/)?)/,\n          // match protocol, allow in format \"http://\" or \"mailto:\". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match \"link:\"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)\n      wwwRegex = /(?:www\\.)/,\n          // starting with 'www.'\n      domainNameRegex = /[A-Za-z0-9\\.\\-]*[A-Za-z0-9\\-]/,\n          // anything looking at all like a domain, non-unicode domains, not ending in a period\n      tldRegex = /\\.(?:international|construction|contractors|enterprises|photography|productions|foundation|immobilien|industries|management|properties|technology|christmas|community|directory|education|equipment|institute|marketing|solutions|vacations|bargains|boutique|builders|catering|cleaning|clothing|computer|democrat|diamonds|graphics|holdings|lighting|partners|plumbing|supplies|training|ventures|academy|careers|company|cruises|domains|exposed|flights|florist|gallery|guitars|holiday|kitchen|neustar|okinawa|recipes|rentals|reviews|shiksha|singles|support|systems|agency|berlin|camera|center|coffee|condos|dating|estate|events|expert|futbol|kaufen|luxury|maison|monash|museum|nagoya|photos|repair|report|social|supply|tattoo|tienda|travel|viajes|villas|vision|voting|voyage|actor|build|cards|cheap|codes|dance|email|glass|house|mango|ninja|parts|photo|shoes|solar|today|tokyo|tools|watch|works|aero|arpa|asia|best|bike|blue|buzz|camp|club|cool|coop|farm|fish|gift|guru|info|jobs|kiwi|kred|land|limo|link|menu|mobi|moda|name|pics|pink|post|qpon|rich|ruhr|sexy|tips|vote|voto|wang|wien|wiki|zone|bar|bid|biz|cab|cat|ceo|com|edu|gov|int|kim|mil|net|onl|org|pro|pub|red|tel|uno|wed|xxx|xyz|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw)\\b/,\n          // match our known top level domains (TLDs)\n      // Allow optional path, query string, and hash anchor, not ending in the following characters: \"?!:,.;\"\n      // http://blog.codinghorror.com/the-problem-with-urls/\n      urlSuffixRegex = /[\\-A-Za-z0-9+&@#\\/%=~_()|'$*\\[\\]?!:,.;]*[\\-A-Za-z0-9+&@#\\/%=~_()|'$*\\[\\]]/;\n      return new RegExp(['(', // *** Capturing group $1, which can be used to check for a twitter handle match. Use group $3 for the actual twitter handle though. $2 may be used to reconstruct the original string in a replace() \n      // *** Capturing group $2, which matches the whitespace character before the '@' sign (needed because of no lookbehinds), and \n      // *** Capturing group $3, which matches the actual twitter handle\n      twitterRegex.source, ')', '|', '(', // *** Capturing group $4, which is used to determine an email match\n      emailRegex.source, domainNameRegex.source, tldRegex.source, ')', '|', '(', // *** Capturing group $5, which is used to match a URL\n      '(?:', // parens to cover match for protocol (optional), and domain\n      '(', // *** Capturing group $6, for a protocol-prefixed url (ex: http://google.com)\n      protocolRegex.source, domainNameRegex.source, ')', '|', '(?:', // non-capturing paren for a 'www.' prefixed url (ex: www.google.com)\n      '(.?//)?', // *** Capturing group $7 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character\n      wwwRegex.source, domainNameRegex.source, ')', '|', '(?:', // non-capturing paren for known a TLD url (ex: google.com)\n      '(.?//)?', // *** Capturing group $8 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character\n      domainNameRegex.source, tldRegex.source, ')', ')', '(?:' + urlSuffixRegex.source + ')?', // match for path, query string, and/or hash anchor - optional\n      ')'].join(\"\"), 'gi');\n    }(),\n\n    /**\n     * @private\n     * @property {RegExp} charBeforeProtocolRelMatchRegex\n     * \n     * The regular expression used to retrieve the character before a protocol-relative URL match.\n     * \n     * This is used in conjunction with the {@link #matcherRegex}, which needs to grab the character before a protocol-relative\n     * '//' due to the lack of a negative look-behind in JavaScript regular expressions. The character before the match is stripped\n     * from the URL.\n     */\n    charBeforeProtocolRelMatchRegex: /^(.)?\\/\\//,\n\n    /**\n     * @private\n     * @property {Autolinker.MatchValidator} matchValidator\n     * \n     * The MatchValidator object, used to filter out any false positives from the {@link #matcherRegex}. See\n     * {@link Autolinker.MatchValidator} for details.\n     */\n\n    /**\n     * @constructor\n     * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).\n     */\n    constructor: function constructor(cfg) {\n      Autolinker.Util.assign(this, cfg);\n      this.matchValidator = new Autolinker.MatchValidator();\n    },\n\n    /**\n     * Parses the input `text` to search for URLs/emails/Twitter handles, and calls the `replaceFn`\n     * to allow replacements of the matches. Returns the `text` with matches replaced.\n     * \n     * @param {String} text The text to search and repace matches in.\n     * @param {Function} replaceFn The iterator function to handle the replacements. The function takes a\n     *   single argument, a {@link Autolinker.match.Match} object, and should return the text that should\n     *   make the replacement.\n     * @param {Object} [contextObj=window] The context object (\"scope\") to run the `replaceFn` in.\n     * @return {String}\n     */\n    replace: function replace(text, replaceFn, contextObj) {\n      var me = this; // for closure\n\n      return text.replace(this.matcherRegex, function (matchStr, $1, $2, $3, $4, $5, $6, $7, $8) {\n        var matchDescObj = me.processCandidateMatch(matchStr, $1, $2, $3, $4, $5, $6, $7, $8); // \"match description\" object\n        // Return out with no changes for match types that are disabled (url, email, twitter), or for matches that are \n        // invalid (false positives from the matcherRegex, which can't use look-behinds since they are unavailable in JS).\n\n        if (!matchDescObj) {\n          return matchStr;\n        } else {\n          // Generate replacement text for the match from the `replaceFn`\n          var replaceStr = replaceFn.call(contextObj, matchDescObj.match);\n          return matchDescObj.prefixStr + replaceStr + matchDescObj.suffixStr;\n        }\n      });\n    },\n\n    /**\n     * Processes a candidate match from the {@link #matcherRegex}. \n     * \n     * Not all matches found by the regex are actual URL/email/Twitter matches, as determined by the {@link #matchValidator}. In\n     * this case, the method returns `null`. Otherwise, a valid Object with `prefixStr`, `match`, and `suffixStr` is returned.\n     * \n     * @private\n     * @param {String} matchStr The full match that was found by the {@link #matcherRegex}.\n     * @param {String} twitterMatch The matched text of a Twitter handle, if the match is a Twitter match.\n     * @param {String} twitterHandlePrefixWhitespaceChar The whitespace char before the @ sign in a Twitter handle match. This \n     *   is needed because of no lookbehinds in JS regexes, and is need to re-include the character for the anchor tag replacement.\n     * @param {String} twitterHandle The actual Twitter user (i.e the word after the @ sign in a Twitter match).\n     * @param {String} emailAddressMatch The matched email address for an email address match.\n     * @param {String} urlMatch The matched URL string for a URL match.\n     * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match\n     *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.\n     * @param {String} wwwProtocolRelativeMatch The '//' for a protocol-relative match from a 'www' url, with the character that \n     *   comes before the '//'.\n     * @param {String} tldProtocolRelativeMatch The '//' for a protocol-relative match from a TLD (top level domain) match, with \n     *   the character that comes before the '//'.\n     *   \n     * @return {Object} A \"match description object\". This will be `null` if the match was invalid, or if a match type is disabled.\n     *   Otherwise, this will be an Object (map) with the following properties:\n     * @return {String} return.prefixStr The char(s) that should be prepended to the replacement string. These are char(s) that\n     *   were needed to be included from the regex match that were ignored by processing code, and should be re-inserted into \n     *   the replacement stream.\n     * @return {String} return.suffixStr The char(s) that should be appended to the replacement string. These are char(s) that\n     *   were needed to be included from the regex match that were ignored by processing code, and should be re-inserted into \n     *   the replacement stream.\n     * @return {Autolinker.match.Match} return.match The Match object that represents the match that was found.\n     */\n    processCandidateMatch: function processCandidateMatch(matchStr, twitterMatch, twitterHandlePrefixWhitespaceChar, twitterHandle, emailAddressMatch, urlMatch, protocolUrlMatch, wwwProtocolRelativeMatch, tldProtocolRelativeMatch) {\n      // Note: The `matchStr` variable wil be fixed up to remove characters that are no longer needed (which will \n      // be added to `prefixStr` and `suffixStr`).\n      var protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch,\n          match,\n          // Will be an Autolinker.match.Match object\n      prefixStr = \"\",\n          // A string to use to prefix the anchor tag that is created. This is needed for the Twitter handle match\n      suffixStr = \"\"; // A string to suffix the anchor tag that is created. This is used if there is a trailing parenthesis that should not be auto-linked.\n      // Return out with `null` for match types that are disabled (url, email, twitter), or for matches that are \n      // invalid (false positives from the matcherRegex, which can't use look-behinds since they are unavailable in JS).\n\n      if (twitterMatch && !this.twitter || emailAddressMatch && !this.email || urlMatch && !this.urls || !this.matchValidator.isValidMatch(urlMatch, protocolUrlMatch, protocolRelativeMatch)) {\n        return null;\n      } // Handle a closing parenthesis at the end of the match, and exclude it if there is not a matching open parenthesis\n      // in the match itself. \n\n\n      if (this.matchHasUnbalancedClosingParen(matchStr)) {\n        matchStr = matchStr.substr(0, matchStr.length - 1); // remove the trailing \")\"\n\n        suffixStr = \")\"; // this will be added after the generated <a> tag\n      }\n\n      if (emailAddressMatch) {\n        match = new Autolinker.match.Email({\n          matchedText: matchStr,\n          email: emailAddressMatch\n        });\n      } else if (twitterMatch) {\n        // fix up the `matchStr` if there was a preceding whitespace char, which was needed to determine the match \n        // itself (since there are no look-behinds in JS regexes)\n        if (twitterHandlePrefixWhitespaceChar) {\n          prefixStr = twitterHandlePrefixWhitespaceChar;\n          matchStr = matchStr.slice(1); // remove the prefixed whitespace char from the match\n        }\n\n        match = new Autolinker.match.Twitter({\n          matchedText: matchStr,\n          twitterHandle: twitterHandle\n        });\n      } else {\n        // url match\n        // If it's a protocol-relative '//' match, remove the character before the '//' (which the matcherRegex needed\n        // to match due to the lack of a negative look-behind in JavaScript regular expressions)\n        if (protocolRelativeMatch) {\n          var charBeforeMatch = protocolRelativeMatch.match(this.charBeforeProtocolRelMatchRegex)[1] || \"\";\n\n          if (charBeforeMatch) {\n            // fix up the `matchStr` if there was a preceding char before a protocol-relative match, which was needed to determine the match itself (since there are no look-behinds in JS regexes)\n            prefixStr = charBeforeMatch;\n            matchStr = matchStr.slice(1); // remove the prefixed char from the match\n          }\n        }\n\n        match = new Autolinker.match.Url({\n          matchedText: matchStr,\n          url: matchStr,\n          protocolUrlMatch: !!protocolUrlMatch,\n          protocolRelativeMatch: !!protocolRelativeMatch,\n          stripPrefix: this.stripPrefix\n        });\n      }\n\n      return {\n        prefixStr: prefixStr,\n        suffixStr: suffixStr,\n        match: match\n      };\n    },\n\n    /**\n     * Determines if a match found has an unmatched closing parenthesis. If so, this parenthesis will be removed\n     * from the match itself, and appended after the generated anchor tag in {@link #processTextNode}.\n     * \n     * A match may have an extra closing parenthesis at the end of the match because the regular expression must include parenthesis\n     * for URLs such as \"wikipedia.com/something_(disambiguation)\", which should be auto-linked. \n     * \n     * However, an extra parenthesis *will* be included when the URL itself is wrapped in parenthesis, such as in the case of\n     * \"(wikipedia.com/something_(disambiguation))\". In this case, the last closing parenthesis should *not* be part of the URL \n     * itself, and this method will return `true`.\n     * \n     * @private\n     * @param {String} matchStr The full match string from the {@link #matcherRegex}.\n     * @return {Boolean} `true` if there is an unbalanced closing parenthesis at the end of the `matchStr`, `false` otherwise.\n     */\n    matchHasUnbalancedClosingParen: function matchHasUnbalancedClosingParen(matchStr) {\n      var lastChar = matchStr.charAt(matchStr.length - 1);\n\n      if (lastChar === ')') {\n        var openParensMatch = matchStr.match(/\\(/g),\n            closeParensMatch = matchStr.match(/\\)/g),\n            numOpenParens = openParensMatch && openParensMatch.length || 0,\n            numCloseParens = closeParensMatch && closeParensMatch.length || 0;\n\n        if (numOpenParens < numCloseParens) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  });\n  /*global Autolinker */\n\n  /*jshint scripturl:true */\n\n  /**\n   * @private\n   * @class Autolinker.MatchValidator\n   * @extends Object\n   * \n   * Used by Autolinker to filter out false positives from the {@link Autolinker#matcherRegex}.\n   * \n   * Due to the limitations of regular expressions (including the missing feature of look-behinds in JS regular expressions),\n   * we cannot always determine the validity of a given match. This class applies a bit of additional logic to filter out any\n   * false positives that have been matched by the {@link Autolinker#matcherRegex}.\n   */\n\n  Autolinker.MatchValidator = Autolinker.Util.extend(Object, {\n    /**\n     * @private\n     * @property {RegExp} invalidProtocolRelMatchRegex\n     * \n     * The regular expression used to check a potential protocol-relative URL match, coming from the \n     * {@link Autolinker#matcherRegex}. A protocol-relative URL is, for example, \"//yahoo.com\"\n     * \n     * This regular expression checks to see if there is a word character before the '//' match in order to determine if \n     * we should actually autolink a protocol-relative URL. This is needed because there is no negative look-behind in \n     * JavaScript regular expressions. \n     * \n     * For instance, we want to autolink something like \"Go to: //google.com\", but we don't want to autolink something \n     * like \"abc//google.com\"\n     */\n    invalidProtocolRelMatchRegex: /^[\\w]\\/\\//,\n\n    /**\n     * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'\n     * \n     * @private\n     * @property {RegExp} hasFullProtocolRegex\n     */\n    hasFullProtocolRegex: /^[A-Za-z][-.+A-Za-z0-9]+:\\/\\//,\n\n    /**\n     * Regex to find the URI scheme, such as 'mailto:'.\n     * \n     * This is used to filter out 'javascript:' and 'vbscript:' schemes.\n     * \n     * @private\n     * @property {RegExp} uriSchemeRegex\n     */\n    uriSchemeRegex: /^[A-Za-z][-.+A-Za-z0-9]+:/,\n\n    /**\n     * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')\n     * \n     * @private\n     * @property {RegExp} hasWordCharAfterProtocolRegex\n     */\n    hasWordCharAfterProtocolRegex: /:[^\\s]*?[A-Za-z]/,\n\n    /**\n     * Determines if a given match found by {@link Autolinker#processTextNode} is valid. Will return `false` for:\n     * \n     * 1) URL matches which do not have at least have one period ('.') in the domain name (effectively skipping over \n     *    matches like \"abc:def\"). However, URL matches with a protocol will be allowed (ex: 'http://localhost')\n     * 2) URL matches which do not have at least one word character in the domain name (effectively skipping over\n     *    matches like \"git:1.0\").\n     * 3) A protocol-relative url match (a URL beginning with '//') whose previous character is a word character \n     *    (effectively skipping over strings like \"abc//google.com\")\n     * \n     * Otherwise, returns `true`.\n     * \n     * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.\n     * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match\n     *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.\n     * @param {String} protocolRelativeMatch The protocol-relative string for a URL match (i.e. '//'), possibly with a preceding\n     *   character (ex, a space, such as: ' //', or a letter, such as: 'a//'). The match is invalid if there is a word character\n     *   preceding the '//'.\n     * @return {Boolean} `true` if the match given is valid and should be processed, or `false` if the match is invalid and/or \n     *   should just not be processed.\n     */\n    isValidMatch: function isValidMatch(urlMatch, protocolUrlMatch, protocolRelativeMatch) {\n      if (protocolUrlMatch && !this.isValidUriScheme(protocolUrlMatch) || this.urlMatchDoesNotHaveProtocolOrDot(urlMatch, protocolUrlMatch) || // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')\n      this.urlMatchDoesNotHaveAtLeastOneWordChar(urlMatch, protocolUrlMatch) || // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like \"git:1.0\"\n      this.isInvalidProtocolRelativeMatch(protocolRelativeMatch) // A protocol-relative match which has a word character in front of it (so we can skip something like \"abc//google.com\")\n      ) {\n          return false;\n        }\n\n      return true;\n    },\n\n    /**\n     * Determines if the URI scheme is a valid scheme to be autolinked. Returns `false` if the scheme is \n     * 'javascript:' or 'vbscript:'\n     * \n     * @private\n     * @param {String} uriSchemeMatch The match URL string for a full URI scheme match. Ex: 'http://yahoo.com' \n     *   or 'mailto:a@a.com'.\n     * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.\n     */\n    isValidUriScheme: function isValidUriScheme(uriSchemeMatch) {\n      var uriScheme = uriSchemeMatch.match(this.uriSchemeRegex)[0].toLowerCase();\n      return uriScheme !== 'javascript:' && uriScheme !== 'vbscript:';\n    },\n\n    /**\n     * Determines if a URL match does not have either:\n     * \n     * a) a full protocol (i.e. 'http://'), or\n     * b) at least one dot ('.') in the domain name (for a non-full-protocol match).\n     * \n     * Either situation is considered an invalid URL (ex: 'git:d' does not have either the '://' part, or at least one dot\n     * in the domain name. If the match was 'git:abc.com', we would consider this valid.)\n     * \n     * @private\n     * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.\n     * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to match\n     *   something like 'http://localhost', where we won't double check that the domain name has at least one '.' in it.\n     * @return {Boolean} `true` if the URL match does not have a full protocol, or at least one dot ('.') in a non-full-protocol\n     *   match.\n     */\n    urlMatchDoesNotHaveProtocolOrDot: function urlMatchDoesNotHaveProtocolOrDot(urlMatch, protocolUrlMatch) {\n      return !!urlMatch && (!protocolUrlMatch || !this.hasFullProtocolRegex.test(protocolUrlMatch)) && urlMatch.indexOf('.') === -1;\n    },\n\n    /**\n     * Determines if a URL match does not have at least one word character after the protocol (i.e. in the domain name).\n     * \n     * At least one letter character must exist in the domain name after a protocol match. Ex: skip over something \n     * like \"git:1.0\"\n     * \n     * @private\n     * @param {String} urlMatch The matched URL, if there was one. Will be an empty string if the match is not a URL match.\n     * @param {String} protocolUrlMatch The match URL string for a protocol match. Ex: 'http://yahoo.com'. This is used to\n     *   know whether or not we have a protocol in the URL string, in order to check for a word character after the protocol\n     *   separator (':').\n     * @return {Boolean} `true` if the URL match does not have at least one word character in it after the protocol, `false`\n     *   otherwise.\n     */\n    urlMatchDoesNotHaveAtLeastOneWordChar: function urlMatchDoesNotHaveAtLeastOneWordChar(urlMatch, protocolUrlMatch) {\n      if (urlMatch && protocolUrlMatch) {\n        return !this.hasWordCharAfterProtocolRegex.test(urlMatch);\n      } else {\n        return false;\n      }\n    },\n\n    /**\n     * Determines if a protocol-relative match is an invalid one. This method returns `true` if there is a `protocolRelativeMatch`,\n     * and that match contains a word character before the '//' (i.e. it must contain whitespace or nothing before the '//' in\n     * order to be considered valid).\n     * \n     * @private\n     * @param {String} protocolRelativeMatch The protocol-relative string for a URL match (i.e. '//'), possibly with a preceding\n     *   character (ex, a space, such as: ' //', or a letter, such as: 'a//'). The match is invalid if there is a word character\n     *   preceding the '//'.\n     * @return {Boolean} `true` if it is an invalid protocol-relative match, `false` otherwise.\n     */\n    isInvalidProtocolRelativeMatch: function isInvalidProtocolRelativeMatch(protocolRelativeMatch) {\n      return !!protocolRelativeMatch && this.invalidProtocolRelMatchRegex.test(protocolRelativeMatch);\n    }\n  });\n  /*global Autolinker */\n\n  /**\n   * @abstract\n   * @class Autolinker.match.Match\n   * \n   * Represents a match found in an input string which should be Autolinked. A Match object is what is provided in a \n   * {@link Autolinker#replaceFn replaceFn}, and may be used to query for details about the match.\n   * \n   * For example:\n   * \n   *     var input = \"...\";  // string with URLs, Email Addresses, and Twitter Handles\n   *     \n   *     var linkedText = Autolinker.link( input, {\n   *         replaceFn : function( autolinker, match ) {\n   *             console.log( \"href = \", match.getAnchorHref() );\n   *             console.log( \"text = \", match.getAnchorText() );\n   *         \n   *             switch( match.getType() ) {\n   *                 case 'url' : \n   *                     console.log( \"url: \", match.getUrl() );\n   *                     \n   *                 case 'email' :\n   *                     console.log( \"email: \", match.getEmail() );\n   *                     \n   *                 case 'twitter' :\n   *                     console.log( \"twitter: \", match.getTwitterHandle() );\n   *             }\n   *         }\n   *     } );\n   *     \n   * See the {@link Autolinker} class for more details on using the {@link Autolinker#replaceFn replaceFn}.\n   */\n\n  Autolinker.match.Match = Autolinker.Util.extend(Object, {\n    /**\n     * @cfg {String} matchedText (required)\n     * \n     * The original text that was matched.\n     */\n\n    /**\n     * @constructor\n     * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).\n     */\n    constructor: function constructor(cfg) {\n      Autolinker.Util.assign(this, cfg);\n    },\n\n    /**\n     * Returns a string name for the type of match that this class represents.\n     * \n     * @abstract\n     * @return {String}\n     */\n    getType: Autolinker.Util.abstractMethod,\n\n    /**\n     * Returns the original text that was matched.\n     * \n     * @return {String}\n     */\n    getMatchedText: function getMatchedText() {\n      return this.matchedText;\n    },\n\n    /**\n     * Returns the anchor href that should be generated for the match.\n     * \n     * @abstract\n     * @return {String}\n     */\n    getAnchorHref: Autolinker.Util.abstractMethod,\n\n    /**\n     * Returns the anchor text that should be generated for the match.\n     * \n     * @abstract\n     * @return {String}\n     */\n    getAnchorText: Autolinker.Util.abstractMethod\n  });\n  /*global Autolinker */\n\n  /**\n   * @class Autolinker.match.Email\n   * @extends Autolinker.match.Match\n   * \n   * Represents a Email match found in an input string which should be Autolinked.\n   * \n   * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n   */\n\n  Autolinker.match.Email = Autolinker.Util.extend(Autolinker.match.Match, {\n    /**\n     * @cfg {String} email (required)\n     * \n     * The email address that was matched.\n     */\n\n    /**\n     * Returns a string name for the type of match that this class represents.\n     * \n     * @return {String}\n     */\n    getType: function getType() {\n      return 'email';\n    },\n\n    /**\n     * Returns the email address that was matched.\n     * \n     * @return {String}\n     */\n    getEmail: function getEmail() {\n      return this.email;\n    },\n\n    /**\n     * Returns the anchor href that should be generated for the match.\n     * \n     * @return {String}\n     */\n    getAnchorHref: function getAnchorHref() {\n      return 'mailto:' + this.email;\n    },\n\n    /**\n     * Returns the anchor text that should be generated for the match.\n     * \n     * @return {String}\n     */\n    getAnchorText: function getAnchorText() {\n      return this.email;\n    }\n  });\n  /*global Autolinker */\n\n  /**\n   * @class Autolinker.match.Twitter\n   * @extends Autolinker.match.Match\n   * \n   * Represents a Twitter match found in an input string which should be Autolinked.\n   * \n   * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n   */\n\n  Autolinker.match.Twitter = Autolinker.Util.extend(Autolinker.match.Match, {\n    /**\n     * @cfg {String} twitterHandle (required)\n     * \n     * The Twitter handle that was matched.\n     */\n\n    /**\n     * Returns the type of match that this class represents.\n     * \n     * @return {String}\n     */\n    getType: function getType() {\n      return 'twitter';\n    },\n\n    /**\n     * Returns a string name for the type of match that this class represents.\n     * \n     * @return {String}\n     */\n    getTwitterHandle: function getTwitterHandle() {\n      return this.twitterHandle;\n    },\n\n    /**\n     * Returns the anchor href that should be generated for the match.\n     * \n     * @return {String}\n     */\n    getAnchorHref: function getAnchorHref() {\n      return 'https://twitter.com/' + this.twitterHandle;\n    },\n\n    /**\n     * Returns the anchor text that should be generated for the match.\n     * \n     * @return {String}\n     */\n    getAnchorText: function getAnchorText() {\n      return '@' + this.twitterHandle;\n    }\n  });\n  /*global Autolinker */\n\n  /**\n   * @class Autolinker.match.Url\n   * @extends Autolinker.match.Match\n   * \n   * Represents a Url match found in an input string which should be Autolinked.\n   * \n   * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n   */\n\n  Autolinker.match.Url = Autolinker.Util.extend(Autolinker.match.Match, {\n    /**\n     * @cfg {String} url (required)\n     * \n     * The url that was matched.\n     */\n\n    /**\n     * @cfg {Boolean} protocolUrlMatch (required)\n     * \n     * `true` if the URL is a match which already has a protocol (i.e. 'http://'), `false` if the match was from a 'www' or\n     * known TLD match.\n     */\n\n    /**\n     * @cfg {Boolean} protocolRelativeMatch (required)\n     * \n     * `true` if the URL is a protocol-relative match. A protocol-relative match is a URL that starts with '//',\n     * and will be either http:// or https:// based on the protocol that the site is loaded under.\n     */\n\n    /**\n     * @cfg {Boolean} stripPrefix (required)\n     * @inheritdoc Autolinker#stripPrefix\n     */\n\n    /**\n     * @private\n     * @property {RegExp} urlPrefixRegex\n     * \n     * A regular expression used to remove the 'http://' or 'https://' and/or the 'www.' from URLs.\n     */\n    urlPrefixRegex: /^(https?:\\/\\/)?(www\\.)?/i,\n\n    /**\n     * @private\n     * @property {RegExp} protocolRelativeRegex\n     * \n     * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes\n     * of {@link #getAnchorText}. A protocol-relative URL is, for example, \"//yahoo.com\"\n     */\n    protocolRelativeRegex: /^\\/\\//,\n\n    /**\n     * @private\n     * @property {Boolean} protocolPrepended\n     * \n     * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the\n     * {@link #url} did not have a protocol)\n     */\n    protocolPrepended: false,\n\n    /**\n     * Returns a string name for the type of match that this class represents.\n     * \n     * @return {String}\n     */\n    getType: function getType() {\n      return 'url';\n    },\n\n    /**\n     * Returns the url that was matched, assuming the protocol to be 'http://' if the original\n     * match was missing a protocol.\n     * \n     * @return {String}\n     */\n    getUrl: function getUrl() {\n      var url = this.url; // if the url string doesn't begin with a protocol, assume 'http://'\n\n      if (!this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended) {\n        url = this.url = 'http://' + url;\n        this.protocolPrepended = true;\n      }\n\n      return url;\n    },\n\n    /**\n     * Returns the anchor href that should be generated for the match.\n     * \n     * @return {String}\n     */\n    getAnchorHref: function getAnchorHref() {\n      var url = this.getUrl();\n      return url.replace(/&amp;/g, '&'); // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html \n    },\n\n    /**\n     * Returns the anchor text that should be generated for the match.\n     * \n     * @return {String}\n     */\n    getAnchorText: function getAnchorText() {\n      var anchorText = this.getUrl();\n\n      if (this.protocolRelativeMatch) {\n        // Strip off any protocol-relative '//' from the anchor text\n        anchorText = this.stripProtocolRelativePrefix(anchorText);\n      }\n\n      if (this.stripPrefix) {\n        anchorText = this.stripUrlPrefix(anchorText);\n      }\n\n      anchorText = this.removeTrailingSlash(anchorText); // remove trailing slash, if there is one\n\n      return anchorText;\n    },\n    // ---------------------------------------\n    // Utility Functionality\n\n    /**\n     * Strips the URL prefix (such as \"http://\" or \"https://\") from the given text.\n     * \n     * @private\n     * @param {String} text The text of the anchor that is being generated, for which to strip off the\n     *   url prefix (such as stripping off \"http://\")\n     * @return {String} The `anchorText`, with the prefix stripped.\n     */\n    stripUrlPrefix: function stripUrlPrefix(text) {\n      return text.replace(this.urlPrefixRegex, '');\n    },\n\n    /**\n     * Strips any protocol-relative '//' from the anchor text.\n     * \n     * @private\n     * @param {String} text The text of the anchor that is being generated, for which to strip off the\n     *   protocol-relative prefix (such as stripping off \"//\")\n     * @return {String} The `anchorText`, with the protocol-relative prefix stripped.\n     */\n    stripProtocolRelativePrefix: function stripProtocolRelativePrefix(text) {\n      return text.replace(this.protocolRelativeRegex, '');\n    },\n\n    /**\n     * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.\n     * \n     * @private\n     * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing\n     *   slash ('/') that may exist.\n     * @return {String} The `anchorText`, with the trailing slash removed.\n     */\n    removeTrailingSlash: function removeTrailingSlash(anchorText) {\n      if (anchorText.charAt(anchorText.length - 1) === '/') {\n        anchorText = anchorText.slice(0, -1);\n      }\n\n      return anchorText;\n    }\n  });\n  return Autolinker;\n});","map":null,"metadata":{},"sourceType":"script"}