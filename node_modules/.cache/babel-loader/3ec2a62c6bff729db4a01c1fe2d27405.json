{"ast":null,"code":"// GFM table, non-standard\n'use strict';\n\nfunction getLine(state, line) {\n  var pos = state.bMarks[line] + state.blkIndent,\n      max = state.eMarks[line];\n  return state.src.substr(pos, max - pos);\n}\n\nmodule.exports = function table(state, startLine, endLine, silent) {\n  var ch, lineText, pos, i, nextLine, rows, cell, aligns, t, tableLines, tbodyLines; // should have at least three lines\n\n  if (startLine + 2 > endLine) {\n    return false;\n  }\n\n  nextLine = startLine + 1;\n\n  if (state.tShift[nextLine] < state.blkIndent) {\n    return false;\n  } // first character of the second line should be '|' or '-'\n\n\n  pos = state.bMarks[nextLine] + state.tShift[nextLine];\n\n  if (pos >= state.eMarks[nextLine]) {\n    return false;\n  }\n\n  ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x7C\n  /* | */\n  && ch !== 0x2D\n  /* - */\n  && ch !== 0x3A\n  /* : */\n  ) {\n      return false;\n    }\n\n  lineText = getLine(state, startLine + 1);\n\n  if (!/^[-:| ]+$/.test(lineText)) {\n    return false;\n  }\n\n  rows = lineText.split('|');\n\n  if (rows <= 2) {\n    return false;\n  }\n\n  aligns = [];\n\n  for (i = 0; i < rows.length; i++) {\n    t = rows[i].trim();\n\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === rows.length - 1) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) {\n      return false;\n    }\n\n    if (t.charCodeAt(t.length - 1) === 0x3A\n    /* : */\n    ) {\n        aligns.push(t.charCodeAt(0) === 0x3A\n        /* : */\n        ? 'center' : 'right');\n      } else if (t.charCodeAt(0) === 0x3A\n    /* : */\n    ) {\n        aligns.push('left');\n      } else {\n      aligns.push('');\n    }\n  }\n\n  lineText = getLine(state, startLine).trim();\n\n  if (lineText.indexOf('|') === -1) {\n    return false;\n  }\n\n  rows = lineText.replace(/^\\||\\|$/g, '').split('|');\n\n  if (aligns.length !== rows.length) {\n    return false;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  state.tokens.push({\n    type: 'table_open',\n    lines: tableLines = [startLine, 0],\n    level: state.level++\n  });\n  state.tokens.push({\n    type: 'thead_open',\n    lines: [startLine, startLine + 1],\n    level: state.level++\n  });\n  state.tokens.push({\n    type: 'tr_open',\n    lines: [startLine, startLine + 1],\n    level: state.level++\n  });\n\n  for (i = 0; i < rows.length; i++) {\n    state.tokens.push({\n      type: 'th_open',\n      align: aligns[i],\n      lines: [startLine, startLine + 1],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: rows[i].trim(),\n      lines: [startLine, startLine + 1],\n      level: state.level,\n      children: []\n    });\n    state.tokens.push({\n      type: 'th_close',\n      level: --state.level\n    });\n  }\n\n  state.tokens.push({\n    type: 'tr_close',\n    level: --state.level\n  });\n  state.tokens.push({\n    type: 'thead_close',\n    level: --state.level\n  });\n  state.tokens.push({\n    type: 'tbody_open',\n    lines: tbodyLines = [startLine + 2, 0],\n    level: state.level++\n  });\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.tShift[nextLine] < state.blkIndent) {\n      break;\n    }\n\n    lineText = getLine(state, nextLine).trim();\n\n    if (lineText.indexOf('|') === -1) {\n      break;\n    }\n\n    rows = lineText.replace(/^\\||\\|$/g, '').split('|');\n    state.tokens.push({\n      type: 'tr_open',\n      level: state.level++\n    });\n\n    for (i = 0; i < rows.length; i++) {\n      state.tokens.push({\n        type: 'td_open',\n        align: aligns[i],\n        level: state.level++\n      }); // 0x7c === '|'\n\n      cell = rows[i].substring(rows[i].charCodeAt(0) === 0x7c ? 1 : 0, rows[i].charCodeAt(rows[i].length - 1) === 0x7c ? rows[i].length - 1 : rows[i].length).trim();\n      state.tokens.push({\n        type: 'inline',\n        content: cell,\n        level: state.level,\n        children: []\n      });\n      state.tokens.push({\n        type: 'td_close',\n        level: --state.level\n      });\n    }\n\n    state.tokens.push({\n      type: 'tr_close',\n      level: --state.level\n    });\n  }\n\n  state.tokens.push({\n    type: 'tbody_close',\n    level: --state.level\n  });\n  state.tokens.push({\n    type: 'table_close',\n    level: --state.level\n  });\n  tableLines[1] = tbodyLines[1] = nextLine;\n  state.line = nextLine;\n  return true;\n};","map":null,"metadata":{},"sourceType":"script"}